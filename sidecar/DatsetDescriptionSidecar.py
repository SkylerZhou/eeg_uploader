# A specific and concrete subclass that inherits from the abstract Sidecar class
#   Inherits common functionality (save(), to_dict(), to_json(), get_logger(), etc) 
#   and adds dataset_description.json specific logic

from jsonschema import Draft202012Validator
from typing import Dict, Any
from .Sidecar import Sidecar # DatasetDescriptionSidecar.py is a subclass of Sidecar.py, this line means DatasetDescriptionSidecar.py inherits from Sidecar.py


class DatasetDescriptionSidecar(Sidecar):
    """
    Represents the dataset_description.json BIDS sidecar.

    - Defines a required JSON structure with defaults
    - Allows user overrides for any field
    - Validates using JSON Schema + logical BIDS checks
    - Warns on missing recommended or unknown extra fields
    """

    default_filename = "dataset_description.json"
    default_bids_path = "bids_root/"

    REQUIRED_FIELDS = {"Name", "BIDSVersion"}
    RECOMMENDED_FIELDS = {"HEDVersion", "DatasetType", "License", "Authors"}
    OPTIONAL_FIELDS = {
        "Keywords",
        "Acknowledgements",
        "HowToAcknowledge",
        "Funding",
        "EthicsApprovals",
        "ReferencesAndLinks",
        "DatasetDOI",
        "GeneratedBy",
    }

    DEFAULTS = {
        "Name": "Unnamed Dataset",
        "BIDSVersion": "1.8.0",
        "DatasetType": "raw",
        "License": "CC-BY-4.0",
        "Authors": ["Unknown"],
        "Acknowledgements": "Generated by Sidecar Generator.",
        "HowToAcknowledge": "Please cite the dataset DOI.",
        "Funding": [],
        "EthicsApprovals": [],
        "ReferencesAndLinks": [],
        "DatasetDOI": "doi:10.xxxxx/placeholder",
        "GeneratedBy": [{"Name": "Sidecar Generator", "Version": "1.0.0"}],
        "Description": "Dataset automatically generated from provided metadata.",
    }

    SCHEMA = {
        "$schema": "https://json-schema.org/draft/2020-12/schema",
        "title": "BIDS Dataset Description",
        "type": "object",
        "required": ["Name", "BIDSVersion", "DatasetType"],
        "properties": {
            "Name": {"type": "string"},
            "BIDSVersion": {"type": "string"},
            "DatasetType": {"type": "string", "enum": ["raw", "derivative"]},
            "License": {"type": "string"},
            "Authors": {"type": "array", "items": {"type": "string"}},
            "Acknowledgements": {"type": "string"},
            "Funding": {"type": "array", "items": {"type": "string"}},
            "Description": {"type": "string"},
        },
        "additionalProperties": True,
    }

    def __init__(self, fields: Dict[str, Any], **kwargs):
        merged_fields = {**self.DEFAULTS, **fields}
        super().__init__(merged_fields, **kwargs)

        self.log.debug(
            f"{self.__class__.__name__} initialized with {len(self.data)} fields "
            f"({len(fields)} user-supplied, {len(self.DEFAULTS)} defaults)."
        )

    def validate(self):
        validator = Draft202012Validator(self.SCHEMA)
        errors = sorted(validator.iter_errors(self.data), key=lambda e: e.path)
        if errors:
            print(errors)
            for err in errors:
                self.log.error(f"Schema error at {list(err.path)}: {err.message}")
            raise ValueError(f"{len(errors)} schema validation errors")

        missing_required = self.REQUIRED_FIELDS - self.data.keys()
        missing_recommended = self.RECOMMENDED_FIELDS - self.data.keys()
        extras = set(self.data.keys()) - (
            self.REQUIRED_FIELDS | self.RECOMMENDED_FIELDS | self.OPTIONAL_FIELDS
        )

        if missing_required:
            raise ValueError(f"Missing REQUIRED fields: {sorted(missing_required)}")

        if missing_recommended:
            self.log.warning(f"Missing RECOMMENDED fields: {sorted(missing_recommended)}")

        if extras:
            self.log.warning(f"Extra (non-BIDS) fields found: {sorted(extras)}")

        self.log.info(f"{self.__class__.__name__} validation passed.")
        return True
